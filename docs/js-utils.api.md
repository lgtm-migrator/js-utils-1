## API Report File for "@apextoaster/js-utils"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import { BaseError } from 'noicejs';
import { ChildProcessWithoutNullStreams } from 'child_process';
import { Logger } from 'noicejs';
import { spawn } from 'child_process';
import { Writable } from 'stream';

// @public (undocumented)
export type AllowedBufferEncoding = 'ascii' | 'utf-8';

// @public
export class ArrayMapper {
    constructor(options: ArrayMapperOptions);
    map(input: Array<string>): Map<string, Array<string>>;
    // (undocumented)
    readonly rest: string;
    // (undocumented)
    readonly skip: number;
    // (undocumented)
    readonly take: Array<string>;
}

// @public (undocumented)
export interface ArrayMapperOptions {
    rest: string;
    skip: number;
    take: Array<string>;
}

// @public
export class Checklist<T> implements ChecklistOptions<T> {
    constructor(options: ChecklistOptions<T>);
    check(value: T): boolean;
    readonly data: Array<T>;
    // (undocumented)
    readonly mode: ChecklistMode;
}

// @public
export enum ChecklistMode {
    // (undocumented)
    EXCLUDE = "exclude",
    // (undocumented)
    INCLUDE = "include"
}

// @public
export interface ChecklistOptions<T> {
    // (undocumented)
    data: Array<T>;
    // (undocumented)
    mode: ChecklistMode;
}

// Warning: (ae-forgotten-export) The symbol "ChildProcessOptions" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export interface ChildOptions extends ChildProcessOptions {
    // (undocumented)
    args: Array<string>;
    // (undocumented)
    command: string;
}

// @public
export class ChildProcessError extends BaseError {
    constructor(msg?: string, ...nested: Array<Error>);
}

// @public (undocumented)
export interface ChildResult {
    // (undocumented)
    status: number;
    // (undocumented)
    stderr: string;
    // (undocumented)
    stdout: string;
}

// Warning: (ae-forgotten-export) The symbol "ChildStreams" needs to be exported by the entry point index.d.ts
//
// @public @deprecated
export function childResult(child: ChildStreams): Promise<ChildResult>;

// @public (undocumented)
export type ChildSpawner = typeof spawn;

// @public
export function concat(chunks: Array<Buffer>): Buffer;

// Warning: (ae-forgotten-export) The symbol "Reflectable" needs to be exported by the entry point index.d.ts
//
// @public
export function constructorName(val: Reflectable): string;

// @public
export function defaultWhen<TVal>(condition: boolean, ...items: Array<TVal>): TVal;

// @public
export function defer(ms: number): Promise<void>;

// Warning: (ae-forgotten-export) The symbol "PredicateC0" needs to be exported by the entry point index.d.ts
//
// @public
export function deferUntil(cb: PredicateC0, step: number, max: number): Promise<void>;

// @public
export function deferValue<T>(ms: number, val: T): Promise<T>;

// @public (undocumented)
export interface Dict<TVal> {
    // (undocumented)
    [key: string]: TVal;
}

// @public
export function doesExist<T>(val: Maybe<T>): val is T;

// @public
export function encode(chunks: Array<Buffer>, encoding: AllowedBufferEncoding): string;

// @public @deprecated (undocumented)
export function ensureArray<T>(val: Maybe<Array<T>>): Array<T>;

// @public (undocumented)
export function ensureArray<T>(val: Maybe<ReadonlyArray<T>>): ReadonlyArray<T>;

// @public
export function entriesOf<TVal>(map: Maybe<MapLike<TVal>>): Array<[string, TVal]>;

// @public
export function filterZip<T1>(cb: (a: T1) => boolean, l1: Array<T1>): Array<T1>;

// @public (undocumented)
export function filterZip<T1, T2>(cb: (a: T1, b: T2) => boolean, l1: Array<T1>, l2: Array<T2>): [Array<T1>, Array<T2>];

// @public (undocumented)
export function filterZip<T1, T2, T3>(cb: (a: T1, b: T2) => boolean, l1: Array<T1>, l2: Array<T2>, l3: Array<T3>): [Array<T1>, Array<T2>, Array<T3>];

// @public (undocumented)
export function filterZip<T1, T2, T3, T4>(cb: (a: T1, b: T2) => boolean, l1: Array<T1>, l2: Array<T2>, l3: Array<T3>, l4: Array<T4>): [Array<T1>, Array<T2>, Array<T3>, Array<T4>];

// @public
export function getConstructor(val: Reflectable): Function;

// @public
export function getHead<TKey, TVal>(map: Map<TKey, ReadonlyArray<TVal>>, key: TKey): TVal;

// @public
export function getHeadOrDefault<TKey, TVal>(map: Map<TKey, ReadonlyArray<Maybe<TVal>>>, key: TKey, defaultValue: TVal): TVal;

// Warning: (ae-forgotten-export) The symbol "Method" needs to be exported by the entry point index.d.ts
//
// @public
export function getMethods<TValue extends Reflectable>(value: TValue): Set<Method<TValue>>;

// @public
export function getOrDefault<TKey, TVal>(map: Map<TKey, TVal>, key: TKey, defaultValue: TVal): TVal;

// @public
export function getTestLogger(verbose?: boolean): Logger;

// @public
export function hasItems<T>(val: Maybe<Array<T>>): val is Array<T>;

// @public (undocumented)
export function hasItems<T>(val: Maybe<ReadonlyArray<T>>): val is ReadonlyArray<T>;

// @public
export class InvalidArgumentError extends BaseError {
    constructor(msg?: string, ...nested: Array<Error>);
}

// @public
export function isArray<TVal>(list: TVal | Array<TVal>): list is Array<TVal>;

// @public
export function isArray<TVal>(list: TVal | ReadonlyArray<TVal>): list is ReadonlyArray<TVal>;

// Warning: (ae-internal-missing-underscore) The name "isDebug" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function isDebug(): boolean;

// @public
export function isEmpty(val: Maybe<Array<unknown> | ReadonlyArray<unknown>>): boolean;

// @public @deprecated
export function isNil<T>(val: Maybe<T>): val is Nil;

// @public
export function isNone<T>(val: Maybe<T>): val is None;

// @public
export function isSome<T>(val: Maybe<T>): val is T;

// @public
export function leftPad(val: string, min?: number, fill?: string): string;

// @public
export function lengthOf(val: Maybe<unknown>): number;

// @public
export function makeDict<TVal>(map: Maybe<MapLike<TVal>>): Dict<TVal>;

// @public
export function makeMap<TVal>(val: Maybe<MapLike<TVal>>): Map<string, TVal>;

// @public
export type MapLike<TVal> = Map<string, TVal> | Dict<TVal>;

// @public
export type Maybe<T> = T | None;

// @public
export function mergeArray<TItem>(...parts: Array<TItem | Array<TItem>>): Array<TItem>;

// @public (undocumented)
export function mergeArray<TItem>(...parts: ReadonlyArray<TItem | ReadonlyArray<TItem>>): ReadonlyArray<TItem>;

// @public @deprecated (undocumented)
export function mergeArrays<TItem>(...parts: Array<TItem | Array<TItem>>): Array<TItem>;

// @public (undocumented)
export function mergeArrays<TItem>(...parts: ReadonlyArray<TItem | ReadonlyArray<TItem>>): ReadonlyArray<TItem>;

// @public
export function mergeMap<TKey, TVal>(target: Map<TKey, TVal>, source: Map<TKey, TVal> | ReadonlyArray<[TKey, TVal]>): Map<TKey, TVal>;

// @public
export class MissingKeyError extends NotFoundError {
    constructor(msg?: string, ...nested: Array<Error>);
}

// @public @deprecated
export function mustCoalesce<T>(...values: Array<Maybe<T>>): T;

// @public
export function mustDefault<T>(...values: Array<Maybe<T>>): T;

// @public
export function mustExist<T>(val: Maybe<T>, err?: string): T;

// Warning: (ae-forgotten-export) The symbol "PredicateC1" needs to be exported by the entry point index.d.ts
//
// @public
export function mustFind<TVal>(list: Array<Maybe<TVal>>, predicate: PredicateC1<TVal>): TVal;

// @public
export function mustGet<TKey, TVal>(map: Map<TKey, TVal>, key: TKey): TVal;

// @public @deprecated
export type Nil = None;

// @public
export type None = null | undefined;

// @public @deprecated
export function normalizeMap(map: MapLike<unknown>): Dict<Array<string>>;

// @public
export class NotFoundError extends BaseError {
    constructor(msg?: string, ...nested: Array<Error>);
}

// @public
export class NotImplementedError extends BaseError {
    constructor(msg?: string, ...nested: Array<Error>);
}

// @public @deprecated
export type Optional<T> = Maybe<T>;

// Warning: (ae-forgotten-export) The symbol "NameValuePair" needs to be exported by the entry point index.d.ts
//
// @public
export function pairsToMap<TVal>(pairs: ReadonlyArray<NameValuePair<TVal>>): Map<string, TVal>;

// @public
export function pushMergeMap<TKey, TVal>(...args: Array<Map<TKey, TVal | Array<TVal>>>): Map<TKey, Array<TVal>>;

// @public
export function pushMergeMap<TKey, TVal>(...args: ReadonlyArray<Map<TKey, TVal | ReadonlyArray<TVal>>>): Map<TKey, ReadonlyArray<TVal>>;

// @public
export function removeNone<TItem>(list: ArrayLike<Maybe<TItem>>): Array<TItem>;

// @public
export function setOrPush<TKey, TVal>(map: Map<TKey, ReadonlyArray<TVal>>, key: TKey, val: TVal | ReadonlyArray<TVal>): Map<TKey, ReadonlyArray<TVal>>;

// @public
export function signal(...signals: Array<NodeJS.Signals>): Promise<NodeJS.Signals>;

// @public (undocumented)
export const SIGNAL_RELOAD: NodeJS.Signals;

// @public (undocumented)
export const SIGNAL_RESET: NodeJS.Signals;

// @public (undocumented)
export const SIGNAL_STOP: NodeJS.Signals;

// Warning: (ae-internal-missing-underscore) The name "spyLogger" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function spyLogger(spies: Partial<Logger>): Logger;

// @public
export function sum(a: number, b: number): number;

// @public
export function timeout<T>(ms: number, inner: Promise<T>): Promise<T>;

// @public
export class TimeoutError extends BaseError {
    constructor(msg?: string, ...nested: Array<Error>);
}

// @public
export function toArray<TVal>(val: Maybe<TVal | Array<TVal>>): Array<TVal>;

// @public
export function toArray<TVal>(val: Maybe<TVal | ReadonlyArray<TVal>>): ReadonlyArray<TVal>;

// @public
export function trim(val: string, max: number, tail?: string): string;

// @public @deprecated (undocumented)
export function waitFor(cb: PredicateC0, step: number, tries: number): Promise<void>;

// @public @deprecated (undocumented)
export function waitForChild(child: ChildStreams): Promise<ChildResult>;

// @public (undocumented)
export function writeInput(stream: Writable, value: string): Promise<boolean>;

// @public @deprecated (undocumented)
export function writeValue(stream: Writable, value: string): Promise<boolean>;

// (No @packageDocumentation comment for this package)

```
